\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\title{Johns Hopkins School of Public Health: Sr. Programmer Analyst Coding Challenge}
\date{October 18, 2024}
\author{Larry D. Lee Jr.}

\begin{document}

\maketitle

\begin{abstract}
In this brief technical note I present the mathematical theory
behind ratio calculations across stratified datasets. I then apply this
theory to work through an example dataset and close by presenting code
samples in R and OCaml.
\end{abstract}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

In real world analysis, we often have to combine and analyze datasets
using different data formats. Frequently, when working with time series
and population datasets, the information is grouped together using
different stratifications. As a result it's important for us to develop
techniques for combining discrepant datasets. In this technical note, I
present the mathematics needed to combine these datasets and illustrate
these mathematical techniques. In the last chapter, I present code
samples in R and OCaml that perform these operations.

\hypertarget{mathematical-background}{%
\section{Mathematical Background}\label{mathematical-background}}

In this section, I briefly review the mathematical background needed to
understand how to combine stratified datasets.

\hypertarget{general-notation}{%
\subsection{General Notation}\label{general-notation}}

Let \(s : set\ T\) represent a set of entities of type \(T\). In
general, \(T\) can represent anything, however, in this technical note,
\(T\) will represent people. We will use the dot notation to reference
attributes. For example, \(s_i.age : \mathbb{R^+}\) will represent a
person's age. Whenever we have a set \(s\), \(|s|\) will denote the
number of elements within it.

\hypertarget{partitions}{%
\subsection{Partitions}\label{partitions}}

A finite \textbf{partition} of a set \(s\) is a finite set of sets
\(p : set\ (set\ T)\) such that \(s = \bigcup_{i=1}^n p_i\) and
\(\forall i, j \in \mathbb{N}, i \neq j \implies p_i \cap p_j = \emptyset\)
where \(n = |p|\). A \textbf{partition function}
\(f : T \rightarrow \mathbb{N}\) is a function that accepts a value
\(s_i\) from \(s\) and returns the index \(j\) of the subset \(p_j\)
that contains \(s_i\) in a partition \(p\).

As a special case we will often consider contiguous clopen interval
partitions (\textbf{CCIPs}) of the positive real number line
\(\mathbb{R}^+\).\footnote{We call intervals that are closed at their
  lower bound and open at their upper bound \textbf{clopen}.} We will
represent these partitions as a list of intervals in ascending order and
will represent the type of such partitions as \([Interval]\). Note that
there are no gaps between these intervals thus:

\begin{align*}
\forall p : [Interval], \forall x \in \mathbb{R}, x \ge p_0.start\ \wedge x < p_n.end \implies \exists p_i \in p, x \in p.
\end{align*}

\hypertarget{stratification}{%
\subsection{Stratification}\label{stratification}}

A \textbf{stratification} is a partition in which elements from \(s\)
are allocated to different subsets \(p\) based some property value such
as age.

In a stratification we take a set of entities of type \(T\), idenfity a
property, such as age, that spans some domain, such as \(\mathbb{R}^+\),
partition that domain \(p\), and then project entities into those
partition sets.

The elements of this scheme are presented in the following diagram:

\textbf{TODO}: create diagram

\hypertarget{rates}{%
\subsection{Rates}\label{rates}}

Let \(f : T \rightarrow \mathbb{B}\) represent a predicate such as the
function that accepts a person and returns true iff the person has a
given disease. We define the \textbf{frequency} of \(f\) over a set
\(s\) as:

\begin{align*}
freq\ (f, s) := |\{x \in s\ |\ f\ (x)\}|.
\end{align*}

The \textbf{rate} of a \(f\) over a set \(s\) is defined as:

\begin{align*}
rate\ (f, s) := \frac{freq\ (f, s)}{|s|}.
\end{align*}

Let \(p\) denote a finite disjoint partition of \(s\) into \(n\)
subsets, then:

\begin{align*}
freq\ (f, s) := \sum_{i=1}^n freq\ (f, p_i)
\end{align*}

and accordingly:

\begin{align}
rate\ (f, s) = \frac{\sum_{i=1}^n freq\ (f, p_i)}{|s|} = \frac{\sum_{i=1}^n rate\ (f, p_i)\ |p_i|}{\sum_{i=1}^n|p_i|}.
\end{align}

We say that a dataset gives the rates of a predicate \(f\) over a
partition \(p\) when the dataset lists the rate of \(f\) for every
element (subset of \(s\)) in \(p\).

\hypertarget{rate-ratios}{%
\subsection{Rate Ratios}\label{rate-ratios}}

Consider the case in which we have two different predicates
\(f, g: T \rightarrow \mathbb{B}\). These two functions may represent
different diseases such as HIV and Gonorrhea for instance. Often, we
want to compare their rates. Their \textbf{rate ratio} over a set \(s\)
is given by:

\begin{align*}
rateRatio (f, g, s) := \frac{rate\ (f, s)}{rate\ (g, s)}.
\end{align*}

Notice that the rate ratio can only be defined when the rates given
apply to the same underlying set. We say that two sets are
\textbf{compatible} if they are equal. We can calculate risk ratios
using rates over two compatible sets.

\hypertarget{refinement-and-coarsening}{%
\subsection{Refinement and Coarsening}\label{refinement-and-coarsening}}

Let \(p, q : set (set\ T)\) represent two partitions of a set \(s\). We
say that \(q\) is a \textbf{refinement} of \(p\) iff for every element
\(p_i\) in \(p\) there exist one or more elements in \(q\) that
collectively represent a partition of \(p\). In other words, there are
one or more elements in \(q\) whose union equals \(p_i\).

\begin{align*}
\forall p_i \in p, \exists r \subseteq q, p_i = \bigcup r. 
\end{align*}

Conversely, we say that \(p\) is a \textbf{coarsening} of \(q\) if \(q\)
is a refinement of \(p\).

We slightly overload our terminology by saying that \(r\) is \(p_i\)'s
\textbf{refinement} in \(q\).'

We can apply this notion to contiguous clopen interval partitions of
\(\mathbb{R}^+\). Let \(p, q : [Interval]\) represent two CCIPs of
\(\mathbb{R}^+\). We say that \(q\) \textbf{refines} \(p\) iff:

\begin{align*}
refines?\ (q, p) := \forall p_i \in p, \exists (j, n \in \mathbb{N}), p_i = \bigcup_{k=j}^{j+n} q_k.
\end{align*}

Conversely, we say that \(p\) \textbf{coarsens} \(q\). We say that \(q\)
is \textbf{more granular} than \(p\) when \(q\) refines \(p\).

\hypertarget{rates-over-coarsening}{%
\subsection{Rates over Coarsening}\label{rates-over-coarsening}}

Let \(p, \pi : [Interval]\) be two CCIPs where \(\pi\) generalizes
\(p\). Let's assume furthermore that we have rates for some predicate
\(f\) over \(p\). We can use (1) to calculate the corresponding rates of
\(f\) over \(\pi\).

If we know the proportion \(prop (p_i) := |p_i|/|s|\) of entities in the
underlying set \(s\) that are grouped within each interval \(p_i\), we
can rewrite (1) as:

\begin{align*}
rate\ (f, \pi) = \sum_{i = 1}^n rate\ (f, p_i)\ prop\ (p_i).
\end{align*}

\hypertarget{rate-ratios-over-coarsening}{%
\subsection{Rate Ratios over
Coarsening}\label{rate-ratios-over-coarsening}}

We can calculate the rate ratios over two partitions \(p\) and \(q\)
when \(q\) is a refinement of \(p\). The rate ratios will be defined for
elements (sets of \(s\)) defined by the less granular partition \(p\).
For every element \(p_i\) in \(p\), let \(r_i\) represent \(p_i\)'s
refinement in \(q\). Then the risk ratio of \(f\) and \(g\) over \(p\)
is given by:

\begin{align*}
rateRatio (f, g, p_i, r_i) := \frac{rate\ (f, p_i)}{rate\ (g, r_i)}.
\end{align*}

\hypertarget{generalization}{%
\subsection{Generalization}\label{generalization}}

Let's say that \(p, q, \pi : [Interval]\) represent three CCIPs of
\(\mathbb{R}^+\). We say that \(\pi\) \textbf{generalizes} \(p\) and
\(q\) iff:

\begin{align*}
generalizes?\ (\pi, p, q) := refines? (\pi, p) \wedge refines?\ (\pi, q).
\end{align*}

Notice that the intervals in \(\pi\) start and end at boundary points
shared by both \(p\) and \(q\).

We say that \(\pi\) is the \textbf{most granular generalization} of
\(p\) and \(q\) iff \(\pi\) refines every other generalization of \(p\)
and \(q\).

\hypertarget{rates-over-generalizations}{%
\subsection{Rates over
Generalizations}\label{rates-over-generalizations}}

\textbf{TODO} revise the algorithm: intervals include proportions and
rates. Generate both the generalized patitions and the pair of imputed
rates.

\hypertarget{rounding-errors}{%
\subsection{Rounding Errors}\label{rounding-errors}}

When working with real world datasets we have to account for the
accumulation of rounding errors when combining rates for partitions.
Imagine that we have an interval and a rate of 0.53. If we extended the
accuracy of the rate to four significant digits, we could find that the
true rate was anything from 0.5250 to 0.5349. If we combine these rates

\hypertarget{regression-estimates}{%
\subsection{Regression Estimates}\label{regression-estimates}}

\hypertarget{confidence-intervals}{%
\subsection{Confidence Intervals}\label{confidence-intervals}}

\hypertarget{code-sample}{%
\section{Code Sample}\label{code-sample}}

The following algorithm accepts two partitions \(p\) and \(q\) and
returns their most granular generalization.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- Represents clopen intervals on R+}
\KeywordTok{type} \DataTypeTok{Interval} \OtherTok{=} \DataTypeTok{Interval}\NormalTok{ \{}
\OtherTok{  start ::} \DataTypeTok{Int}\NormalTok{,}
\OtherTok{  end   ::} \DataTypeTok{Int}
\NormalTok{\}}

\CommentTok{-- Accepts two interval partitions and returns their union - i.e. the most granualar partition that includes both.}
\OtherTok{scan ::}\NormalTok{ [}\DataTypeTok{Interval}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval}\NormalTok{]}
\NormalTok{scan [] _ }\OtherTok{=}\NormalTok{ []}
\NormalTok{scan _ [] }\OtherTok{=}\NormalTok{ []}
\NormalTok{scan xs}\OperatorTok{@}\NormalTok{(x}\OperatorTok{:}\NormalTok{xs') ys}\OperatorTok{@}\NormalTok{(y}\OperatorTok{:}\NormalTok{ys')}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{start }\OtherTok{=}\NormalTok{ y}\OperatorTok{.}\NormalTok{start }\OtherTok{=}\NormalTok{ stretch x}\OperatorTok{.}\NormalTok{start xs ys}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{start }\OperatorTok{<}\NormalTok{ y}\OperatorTok{.}\NormalTok{start }\OtherTok{=}\NormalTok{ scan xs' ys}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{start }\OperatorTok{>}\NormalTok{ y}\OperatorTok{.}\NormalTok{start }\OtherTok{=}\NormalTok{ scan xs ys'}

\CommentTok{-- stretches a current interval and then resumes scanning for common intervals.}
\OtherTok{stretch ::} \DataTypeTok{Int} \OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval}\NormalTok{]}
\NormalTok{stretch _ [] _ }\OtherTok{=}\NormalTok{ []}
\NormalTok{stretch _ _ [] }\OtherTok{=}\NormalTok{ []}
\NormalTok{stretch start xs}\OperatorTok{@}\NormalTok{(x}\OperatorTok{:}\NormalTok{xs') ys}\OperatorTok{@}\NormalTok{(y}\OperatorTok{:}\NormalTok{ys')}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{end }\OtherTok{=}\NormalTok{ y}\OperatorTok{.}\NormalTok{end }\OtherTok{=}\NormalTok{ (}\DataTypeTok{Interval}\NormalTok{ start x}\OperatorTok{.}\NormalTok{end)}\OperatorTok{:}\NormalTok{(scan xs' ys')}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{end }\OperatorTok{<}\NormalTok{ y}\OperatorTok{.}\NormalTok{end }\OtherTok{=}\NormalTok{ stretch start xs' ys}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{end }\OperatorTok{>}\NormalTok{ y}\OperatorTok{.}\NormalTok{end }\OtherTok{=}\NormalTok{ stretch start xs ys'}
\end{Highlighting}
\end{Shaded}

Notice that the algorithm runs in linear time.

\hypertarget{illustrated-example}{%
\section{Illustrated Example}\label{illustrated-example}}

Let's focus specifically on the following scenario. We have a population
of people represented by the set \(s\) and two datasets. \(D_0\) and
\(D_1\). The first dataset stratifies the people in \(s\) by age using
partition \(p\). The second stratifies people by age using different age
ranges. Its partition is denoted by \(q\). Thus, every set in \(p\) and
\(q\) corresponds to an interval on the positive real number line
\(\mathbb{R}^+\). We do not require \(q\) to be a refinement of \(p\) or
vice versa. Instead, given an interval \(p_i\) in \(p\), there may or
may not exist one or more intervals in \(q\) that partitions \(p_i\) -
i.e. there may or may not exist a refinement of \(p_i\) in \(q\). We
want to identify the most granular partition \(\pi\) of \(\mathbb{R}^+\)
that is compatible with both \(p\) and \(q\) and then calculate the rate
ratios for every element in \(\pi\).

\hypertarget{conclusion}{%
\section{Conclusion}\label{conclusion}}

\hypertarget{appendix-1-rates-over-generalized-partitions}{%
\section{Appendix 1: Rates Over Generalized
Partitions}\label{appendix-1-rates-over-generalized-partitions}}

In the following code snippet, we present a set of functions that accept
two partitions for which we have rates and returns the corresponding
rates for their most granular generalization.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- Represents information about entities in an interval}
\KeywordTok{type} \DataTypeTok{Info}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Info}\NormalTok{ \{}
\OtherTok{  rate       ::}\NormalTok{ a,}
\OtherTok{  proportion ::} \DataTypeTok{Float}
\NormalTok{\}}

\CommentTok{-- Represents clopen intervals on R+}
\KeywordTok{type} \DataTypeTok{Interval}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Interval}\NormalTok{ \{}
\OtherTok{  info  ::} \DataTypeTok{Info}\NormalTok{ a,}
\OtherTok{  start ::} \DataTypeTok{Int}\NormalTok{,}
\OtherTok{  end   ::} \DataTypeTok{Int}
\NormalTok{\}}

\CommentTok{-- Accepts two interval partitions and returns their union - i.e. the most granualar partition that includes both.}
\OtherTok{scan ::}\NormalTok{ [}\DataTypeTok{Interval} \DataTypeTok{Float}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval} \DataTypeTok{Float}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval}\NormalTok{ (}\DataTypeTok{Float}\NormalTok{, }\DataTypeTok{Float}\NormalTok{)]}
\NormalTok{scan [] _ }\OtherTok{=}\NormalTok{ []}
\NormalTok{scan _ [] }\OtherTok{=}\NormalTok{ []}
\NormalTok{scan xs}\OperatorTok{@}\NormalTok{(x}\OperatorTok{:}\NormalTok{xs') ys}\OperatorTok{@}\NormalTok{(y}\OperatorTok{:}\NormalTok{ys')}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{start }\OtherTok{=}\NormalTok{ y}\OperatorTok{.}\NormalTok{start }\OtherTok{=}\NormalTok{ stretch x}\OperatorTok{.}\NormalTok{start (}\DataTypeTok{Info} \DecValTok{0} \DecValTok{0}\NormalTok{) xs ys}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{start }\OperatorTok{<}\NormalTok{ y}\OperatorTok{.}\NormalTok{start }\OtherTok{=}\NormalTok{ scan xs' ys}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{start }\OperatorTok{>}\NormalTok{ y}\OperatorTok{.}\NormalTok{start }\OtherTok{=}\NormalTok{ scan xs ys'}

\CommentTok{-- stretches a current interval and then resumes scanning for common intervals.}
\OtherTok{stretch ::} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Info}\NormalTok{ (}\DataTypeTok{Float}\NormalTok{, }\DataTypeTok{Float}\NormalTok{) }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval} \DataTypeTok{Float}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval} \DataTypeTok{Float}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval}\NormalTok{ (}\DataTypeTok{Float}\NormalTok{, }\DataTypeTok{Float}\NormalTok{)]}
\NormalTok{stretch _ _ [] _ }\OtherTok{=}\NormalTok{ []}
\NormalTok{stretch _ _ _ [] }\OtherTok{=}\NormalTok{ []}
\NormalTok{stretch start info xs}\OperatorTok{@}\NormalTok{(x}\OperatorTok{:}\NormalTok{xs') ys}\OperatorTok{@}\NormalTok{(y}\OperatorTok{:}\NormalTok{ys')}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{end }\OtherTok{=}\NormalTok{ y}\OperatorTok{.}\NormalTok{end }\OtherTok{=}
\NormalTok{    (}\DataTypeTok{Interval}
\NormalTok{      \{}
\NormalTok{        rate }\OtherTok{=}\NormalTok{ (}
          \FunctionTok{fst}\NormalTok{ info}\OperatorTok{.}\NormalTok{rate }\OperatorTok{+}\NormalTok{ x}\OperatorTok{.}\NormalTok{info}\OperatorTok{.}\NormalTok{rate }\OperatorTok{*}\NormalTok{ x}\OperatorTok{.}\NormalTok{info}\OperatorTok{.}\NormalTok{proportion,}
          \FunctionTok{snd}\NormalTok{ info}\OperatorTok{.}\NormalTok{rate }\OperatorTok{+}\NormalTok{ y}\OperatorTok{.}\NormalTok{info}\OperatorTok{.}\NormalTok{rate }\OperatorTok{*}\NormalTok{ y}\OperatorTok{.}\NormalTok{info}\OperatorTok{.}\NormalTok{proportion}
\NormalTok{        ),}
\NormalTok{        proportion }\OtherTok{=}\NormalTok{ info}\OperatorTok{.}\NormalTok{proportion }\OperatorTok{+}\NormalTok{ x}\OperatorTok{.}\NormalTok{info}\OperatorTok{.}\NormalTok{proportion}
\NormalTok{      \}}
\NormalTok{      start x}\OperatorTok{.}\NormalTok{end)}\OperatorTok{:}
\NormalTok{    (scan xs' ys')}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{end }\OperatorTok{<}\NormalTok{ y}\OperatorTok{.}\NormalTok{end }\OtherTok{=}\NormalTok{ stretch start}
\NormalTok{    \{}
\NormalTok{      rate }\OtherTok{=}\NormalTok{ (}
        \FunctionTok{fst}\NormalTok{ info}\OperatorTok{.}\NormalTok{rate }\OperatorTok{+}\NormalTok{ x}\OperatorTok{.}\NormalTok{info}\OperatorTok{.}\NormalTok{rate }\OperatorTok{*}\NormalTok{ x}\OperatorTok{.}\NormalTok{info}\OperatorTok{.}\NormalTok{proportion,}
        \FunctionTok{snd}\NormalTok{ info}\OperatorTok{.}\NormalTok{rate}
\NormalTok{      ),}
\NormalTok{      proportion }\OtherTok{=}\NormalTok{ info}\OperatorTok{.}\NormalTok{proportion }\OperatorTok{+}\NormalTok{ x}\OperatorTok{.}\NormalTok{info}\OperatorTok{.}\NormalTok{proportion}
\NormalTok{    \}}
\NormalTok{    xs' ys}
  \OperatorTok{|}\NormalTok{ x}\OperatorTok{.}\NormalTok{end }\OperatorTok{>}\NormalTok{ y}\OperatorTok{.}\NormalTok{end }\OtherTok{=}\NormalTok{ stretch start}
\NormalTok{    \{}
\NormalTok{      rate }\OtherTok{=}\NormalTok{ (}
        \FunctionTok{fst}\NormalTok{ info}\OperatorTok{.}\NormalTok{rate,}
        \FunctionTok{snd}\NormalTok{ info}\OperatorTok{.}\NormalTok{rate }\OperatorTok{+}\NormalTok{ y}\OperatorTok{.}\NormalTok{info}\OperatorTok{.}\NormalTok{rate }\OperatorTok{+}\NormalTok{ y}\OperatorTok{.}\NormalTok{info}\OperatorTok{.}\NormalTok{proportion}
\NormalTok{      ),}
\NormalTok{      proportion }\OtherTok{=}\NormalTok{ info}\OperatorTok{.}\NormalTok{proportion}
\NormalTok{    \}}
\NormalTok{    info xs ys'}

\CommentTok{-- Accepts two interval partitions and returns the rate ratios for their generalized partion.}
\OtherTok{getRateRatios ::}\NormalTok{ [}\DataTypeTok{Interval} \DataTypeTok{Float}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval} \DataTypeTok{Float}\NormalTok{] }\OtherTok{->}\NormalTok{ [}\DataTypeTok{Interval} \DataTypeTok{Float}\NormalTok{]}
\NormalTok{getRateRatios p q }\OtherTok{=} \FunctionTok{map}\NormalTok{ (\textbackslash{}x }\OtherTok{->}\NormalTok{ x \{info }\OtherTok{=}\NormalTok{ (}\FunctionTok{fst}\NormalTok{ x}\OperatorTok{.}\NormalTok{info)}\OperatorTok{/}\NormalTok{(}\FunctionTok{snd}\NormalTok{ x}\OperatorTok{.}\NormalTok{info)\}) }\OperatorTok{$}\NormalTok{ scan p q }
\end{Highlighting}
\end{Shaded}

\end{document}
