\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\title{Johns Hopkins School of Public Health Coding Challenge}
\author{Larry D. Lee Jr.}
\date{October 18, 2024\\REVISED: November 7, 2024}

\begin{document}

\maketitle

\begin{quote}
Abstract: This technical note answers the questions presented in Johns
Hopkins School of Public Health's (JHSPH) Coding Challenge. In this
note, I review the mathematical theory behind combining datasets that
use different stratifications and present code that combines these
datasets.
\end{quote}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

This technical note answers the questions presented in Johns Hopkins
School of Public Health's (JHSPH) Coding Challenge. This coding
challenge consisted of two parts. The challenge provided four datasets
that described the age distribution of Baltimore City residents and the
prevalence rates of Gonorrhea, HIV, and heroin use across different age
intervals. The first part of the coding challenge asked the interviewee
to answer the following questions using the datasets:

\begin{quote}
"Using these four datasets, calculate the following quantities, or if
they cannot be calculated exactly, explain why

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The ratio of gonorrhea rate to HIV diagnosis rate among people ages
  25-44, and among people ages 45 or greater, in 2020
\item
  The ratio of heroin use rate to HIV diagnosis rate among people ages
  12 and older in 2020"
\end{enumerate}
\end{quote}

The second part asked the interviewee to write a function that:

\begin{quote}
"... takes three datasets as inputs (two with rates per population and
one with population) and returns the ratio of these rates by the most
granular age brackets possible"
\end{quote}

In this note, I answer these questions and present R code that
implements this function. Additionally, I review the mathematics behind
data stratification and associated algorithms.

\hypertarget{mathematical-background}{%
\section{Mathematical Background}\label{mathematical-background}}

In this section, I briefly review the mathematical background needed to
understand how to combine stratified datasets.

\hypertarget{general-notation}{%
\subsection{General Notation}\label{general-notation}}

Let \(s : set\ T\) represent a set of entities of type \(T\). In
general, \(T\) can represent anything, however, in this technical note,
\(T\) will represent people. We will use the dot notation to reference
attributes. For example, \(s_i.age : \mathbb{R^+}\) will represent a
person's age. Whenever we have a set \(s\), \(|s|\) will denote the
number of elements within it.

\hypertarget{partitions}{%
\subsection{Partitions}\label{partitions}}

A finite \textbf{partition} of a set \(s\) is a finite set of \(n\) sets
\(p : set\ (set\ T)\) such that \(s = \bigcup_{i=1}^n p_i\) and
\(\forall i, j \in \mathbb{N}, i \neq j \implies p_i \cap p_j = \emptyset\).
A \textbf{partition function} \(f_p : T \rightarrow \mathbb{N}\) is a
function that accepts a value \(s_i\) from \(s\) and returns the index
\(j\) of the subset \(p_j\) that contains \(s_i\) in a partition \(p\).

As a special case we will often consider contiguous clopen interval
partitions (\textbf{CCIPs}) of the positive real number line
\(\mathbb{R}^+\).\footnote{We call intervals that are closed at their
  lower bound and open at their upper bound \textbf{clopen}.} We will
represent these partitions as a list of intervals in ascending order and
will represent the type of such partitions as \([Interval]\). Note that
there are no gaps between these intervals thus:

\begin{align*}
\forall p : [Interval], \forall x \in \mathbb{R}, x \ge p_0.start\ \wedge x < p_n.end \implies \exists p_i \in p, x \in p.
\end{align*}

We will also consider uniform contiguous clopen interval partitions
(\textbf{uCCIPs}) of the positive real number line \(\mathbb{R}^+.\)
These are CCIPs where every interval has a uniform width \(w\).

\hypertarget{stratification}{%
\subsection{Stratification}\label{stratification}}

A \textbf{stratification} is a partition \(p\) of some set \(A\) in
which elements from \(s\) are allocated to different sets in \(p\) based
some property value such as age. For this technical note, \(A\) will
always be the positive real number line \(\mathbb{R}^+\).

In a stratification we take a set of entities of type \(T\), identify a
property, such as age, that spans some domain, such as \(\mathbb{R}^+\),
partition that domain \(p\), and then project entities into those
partition sets.

\hypertarget{rates}{%
\subsection{Rates}\label{rates}}

Let \(f : T \rightarrow \mathbb{B}\) represent a predicate such as the
function that accepts a person and returns true iff the person has a
given disease. We define the \textbf{frequency} of \(f\) over a set
\(s\) as:

\begin{align*}
freq\ (f, s) := |\{x \in s\ |\ f\ (x)\}|.
\end{align*}

The \textbf{rate} of a \(f\) over a set \(s\) is defined as:

\begin{align*}
rate\ (f, s) := \frac{freq\ (f, s)}{|s|}.
\end{align*}

Let \(p\) denote a finite disjoint partition of \(s\) into \(n\)
subsets, then:

\begin{align*}
freq\ (f, s) := \sum_{i=1}^n freq\ (f, p_i)
\end{align*}

and accordingly:

\begin{align}
rate\ (f, s) = \frac{\sum_{i=1}^n freq\ (f, p_i)}{|s|} = \frac{\sum_{i=1}^n rate\ (f, p_i)\ |p_i|}{\sum_{i=1}^n|p_i|}.
\end{align}

We say that a dataset gives the rates of a predicate \(f\) over a
partition \(p\) when the dataset lists the rate of \(f\) for every
element (subset of \(s\)) in \(p\).

\hypertarget{rate-ratios}{%
\subsection{Rate Ratios}\label{rate-ratios}}

Consider the case in which we have two different predicates
\(f, g: T \rightarrow \mathbb{B}\). These two functions may represent
different diseases such as HIV and Gonorrhea for instance. Often, we
want to compare their rates. Their \textbf{rate ratio} over a set \(s\)
is given by:

\begin{align*}
rateRatio (f, g, s) := \frac{rate\ (f, s)}{rate\ (g, s)} = \frac{freq\ (f, s)}{freq\ (g, s)}.
\end{align*}

Notice that the rate ratio can only be defined when the rates given
apply to the same underlying set. We say that two sets are
\textbf{compatible} if they are equal. We can calculate risk ratios
using rates over two compatible sets. Also note that the risk ratio of
\(f\) and \(g\) can be calculated by taking the ratio of their
frequencies over \(s\).

\hypertarget{refinement-and-coarsening}{%
\subsection{Refinement and Coarsening}\label{refinement-and-coarsening}}

Let \(p, q : set (set\ T)\) represent two partitions of a set \(s\). We
say that \(q\) is a \textbf{refinement} of \(p\) iff for every element
\(p_i\) in \(p\) there exist one or more elements in \(q\) that
collectively represent a partition of \(p_i\). In other words, there are
one or more elements in \(q\) whose union equals \(p_i\).

\begin{align*}
\forall p_i \in p, \exists r \subseteq q, p_i = \bigcup r. 
\end{align*}

Conversely, we say that \(p\) is a \textbf{coarsening} of \(q\) if \(q\)
is a refinement of \(p\).

We slightly overload our terminology by saying that \(r\) is \(p_i\)'s
\textbf{refinement} in \(q\).'

We can apply this notion to contiguous clopen interval partitions of
\(\mathbb{R}^+\). Let \(p, q : [Interval]\) represent two CCIPs of
\(\mathbb{R}^+\). We say that \(q\) \textbf{refines} \(p\) iff:

\begin{align*}
refines?\ (q, p) := \forall p_i \in p, \exists (j, n \in \mathbb{N}), p_i = \bigcup_{k=j}^{j+n} q_k.
\end{align*}

Conversely, we say that \(p\) \textbf{coarsens} \(q\). We say that \(q\)
is \textbf{more granular} than \(p\) when \(q\) refines \(p\).

\hypertarget{rates-over-coarsening}{%
\subsection{Rates over Coarsening}\label{rates-over-coarsening}}

Let \(p, q : [Interval]\) be two CCIPs where \(q\) coarsens \(p\). Let's
assume furthermore that we have rates for some predicate \(f\) over
\(p\). We can use (1) to calculate the corresponding rates of \(f\) over
\(q\). To do this, we apply the following algorithm. For every interval
\(q_i\) in \(q\), identify the sublist of intervals \(r_i\) in \(p\)
that refine \(q_i\). Use (1) to calculate the rate of \(f\) over
\(q_i\):

\begin{align*}
  rate\ (f, q_i) = \frac{\sum_{i=1}^n freq\ (f, r_i)}{|q_i|}.
\end{align*}

If we know the proportion \(prop (r_i) := |r_i|/|q_i|\) of entities in
the underlying set \(q_i\) that are grouped within each interval
\(r_i\), we can rewrite this as:

\begin{align*}
rate\ (f, q_i) = \sum_{i = 1}^n rate\ (f, r_i)\ prop\ (r_i).
\end{align*}

\hypertarget{rate-ratios-over-coarsening}{%
\subsection{Rate Ratios over
Coarsening}\label{rate-ratios-over-coarsening}}

We can calculate the rate ratios over two partitions \(p\) and \(q\)
when \(q\) is a refinement of \(p\). The rate ratios will be defined for
elements (sets of \(s\)) defined by the less granular partition \(p\).
For every element \(p_i\) in \(p\), let \(r_i\) represent \(p_i\)'s
refinement in \(q\). Then the risk ratio of \(f\) and \(g\) over \(p\)
is given by:

\begin{align*}
rateRatio (f, g, p_i, r_i) := \frac{rate\ (f, p_i)}{rate\ (g, r_i)} = \frac{freq\ (f, p_i)}{freq\ (g, r_i)}.
\end{align*}

\hypertarget{generalization}{%
\subsection{Generalization}\label{generalization}}

Let's say that \(p, q, \pi : [Interval]\) represent three CCIPs of
\(\mathbb{R}^+\). We say that \(\pi\) \textbf{generalizes} \(p\) and
\(q\) iff:

\begin{align*}
generalizes?\ (\pi, p, q) := refines? (p, \pi) \wedge refines?\ (q, \pi).
\end{align*}

We say that \(\pi\) is the \textbf{most granular generalization} of
\(p\) and \(q\) iff \(\pi\) refines every other generalization of \(p\)
and \(q\).

We can easily prove that the intervals in \(\pi\) start and end at
boundary points shared by both \(p\) and \(q\). What's more, we can
define an algorithm that accepts two arbitrary CCIPs and returns there
most granular generalization. This algorithm is a scanning algorithm and
runs in linear time. The \texttt{rebase} function defined in the code
sample presented in Appendix 2 presents an implementation of this
algorithm in R.

\hypertarget{incompatible-partitions}{%
\subsection{Incompatible Partitions}\label{incompatible-partitions}}

Consider the case where we have two datasets that have been stratified
using two partitions \(p\) and \(q\). Assume, furthermore that \(p\) and
\(q\) have no common start and endpoints in common. In this instance, we
say that \(p\) and \(q\) are \textbf{incompatible} as their
generalization is the empty set \(\empty\).

In general, we cannot safely combine incompatible datasets. To see this
consider the following scenario in which \(p = [[0, 2]]\) and and
\(q = [[1, 2]]\). Assume that 100 people in \(p_1\) have condition \(x\)
and that 50 people in \(q_1\) have condition \(y\). We cannot safely
calculate the overlap between these two groups because we do not know if
all of the people in \(p_1\) with condition \(x\) fall within the
interval \([0, 1]\), \([1, 2]\), or are distributed between them. Thus,
the overlap could be 0, 100\%, or any value in between.

If however, we can make additional assumptions about the underlying
distribution of people across the domain partitioned by \(p\) and \(q\),
such as assuming that the distribution is approximately uniform within
each interval, we can use regression and interpolation techniques to
estimate these overlaps.

\hypertarget{rounding-errors}{%
\subsection{Rounding Errors}\label{rounding-errors}}

When working with real-world datasets we have to account for the
accumulation of rounding errors when combining rates across partition
subsets and intervals. Imagine that we have an interval and a rate of
0.53. If we extended the accuracy of the rate to four significant
digits, we find that the true rate could have been any value between
0.5250 and 0.5349. In general, when we perform arithmetic operations
over these estimates, our precision will degrade.

\hypertarget{answers}{%
\section{Answers}\label{answers}}

The Interview challenge opens with the following questions:

\begin{quote}
PART 1: Using these four datasets, calculate the following quantities,
or if they cannot be calculated exactly, explain why

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The ratio of gonorrhea rate to HIV diagnosis rate among people ages
  25-44, and among people ages 45 or greater, in 2020
\item
  The ratio of heroin use rate to HIV diagnosis rate among people ages
  12 and older in 2020
\end{enumerate}

PART 3: We have counts of new gonorrhea diagnoses in age groups: 0-14
years, 15-19 years, 20-24 years, 25-34 years, 35-39 years, 40-44 years,
45-54 years, 55-64 years, and 65+ years old. We want to estimate the
count of new gonorrhea diagnoses for each individual age from 0 to 85.

Describe an algorithm that will create single-year age estimates of new
gonorrhea diagnosis counts. What assumptions does your algorithm make?
There are a range of reasonable answers.
\end{quote}

\hypertarget{part-1-answers}{%
\subsection{Part 1 Answers}\label{part-1-answers}}

I've included a code package that includes code written in R to answer
these questions. We can calculate the frequency of Gonorrhea and HIV for
each of the age ranges included in the given datasets. We can then
calculate the sum of people in both datasets who have these conditions
in the 25-44 age cohorts. Dividing these sums we find that:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  (a) The ratio of gonorrhea rate to HIV diagnosis rate among people
  aged 25-44 is \textbf{19.8}.
\end{enumerate}

Note that this calculation is approximate but accurate to 3 significant
digits. We relied on underlying rate estimates for Gonorrhea and HIV.
Both of these datasets rounded rate estimates to the nearest tenth of
1/100,000th. Thus, given an estimate such as 25.7 per 100,000, the true
rate is anywhere between 25.65 and 25.74. These errors can compound
enough to shift our estimate but not by enough to alter the figure
given. If we extend our estimate to four significant digits the
potential error ranges from 19.82 to 19.84.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  (b) The ratio of gonorrhea rate to HIV diagnosis rate among people
  aged 45 and older is \textbf{6.7}
\end{enumerate}

This calculation is accurate to the number of digits shown. However,
given the rounding error implicit in the underlying rate estimates for
Gonorrhea and HIV, the true ratio could range from 6.72 to 6.75.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  We cannot accurately estimate the ratio of heroin use rate to HIV
  diagnosis rate for people ages 12 and older.
\end{enumerate}

The reason we cannot estimate this datum is because the age partitions
used by the HIV rate dataset and the population age distribution are not
compatible (as defined above). The best that we can do is to use some
form of curve fitting or interpolation to estimate population density
over age and then use this to estimate the number of people falling
within the age ranges used by the heroin dataset.

\hypertarget{part-2-answers}{%
\subsection{Part 2 Answers}\label{part-2-answers}}

The interview challenge continues by giving a specification for a
function that "... takes three datasets as inputs (two with rates per
population and one with population) and returns the ratio of these rates
by the most granular age brackets possible". The \texttt{getRateRatio}
function defined in the code sample given in Appendix 2 implements this
function specification.

\hypertarget{part-3-answers}{%
\subsection{Part 3 Answers}\label{part-3-answers}}

In Appendix 1, we describe a range of methods for refining partitions
and estimating population distributions across those refinements.
Specifically, the functions \texttt{refineUniform} and
\texttt{refineLinear} presented in Appendix 2 implement the algorithms
described in Appendix 1.

\hypertarget{appendix-1-incompatible-partitions}{%
\section{Appendix 1: Incompatible
Partitions}\label{appendix-1-incompatible-partitions}}

In this appendix, we consider those situations in which we have two
datasets that use incompatible partitions.

In general, we cannot safely combine incompatible datasets. To see this
consider the following scenario in which \(p = [[0, 2]]\) and and
\(q = [[1, 2]]\). Assume that 100 people in \(p_1\) have condition \(x\)
and that 50 people in \(q_1\) have condition \(y\). We cannot safely
calculate the overlap between these two groups because we do not know if
all of the people in \(p_1\) with condition \(x\) fall within the
interval \([0, 1]\), \([1, 2]\), or are distributed between them. Thus,
the overlap could be 0, 100\%, or any value in between.

If however, we can make additional assumptions about the underlying
distribution of people across the domain partitioned by \(p\) and \(q\)
we can estimate the overlap between partition sets.

\hypertarget{additional-assumptions}{%
\subsection{Additional Assumptions}\label{additional-assumptions}}

The fundamental problem is that we do not know how a population is
distributed within any partition interval \(p_i\). If we subdivide
\(p_i\) into two equal subintervals \(p_{i,0}\) and \(p_{i,1}\), we find
that all of the people within \(p_i\) fall within one, the other, or are
distributed between both.

We want to be able to refine partitions and estimate the number of
people within those refined subintervals. That is, we want to be able to
subdivide each partition interval \(p_i\) into a set of subintervals
\(r_i\) and estimate the population falling within each interval.

To do this, we must first ask ourselves what makes a good estimate. The
worst that we can do is subdivide an interval into \(n\) subintervals
and discover that the entire population is concentrated into just one of
them. The best that we can do is exactly estimate the proportion of the
population in each of them.

Thus, we want to ensure that we are only dealing with distributions for
which our maximum interval estimate error has some finite bound. This
suggests that our criteria will vary based on our estimation technique.
For example, if we assume that population is distributed evenly within a
partition interval and the real population is not distributed evenly,
the proportional estimate error is unbound.

Let \(f : \mathbb{R}^+ \rightarrow \mathbb{R}^+\) represent the
underlying probability distribution over some set \(s : \mathbb{R}^+\)
such as potential ages. It is often natural to assume that \(f\) is
\textbf{differentiable} and whose derivative magnitude is bounded by
some constant \(\kappa\).

\begin{align*}
\forall x \in \mathbb{R}^+, |\frac{d f (x)}{dx}| \le \kappa. 
\end{align*}

Many theoretical distribution functions satisfy this requirement. For
example, both the normal distribution function and the log-normal
distribution functions do.

Given this assumption, we can define concrete bounds on the number of
people who can potentially be in our intervals. Let \(p_i\) represent an
interval \([a, a + w]\) of width \(w\) that contains \(|s_i|\) people.
Let's consider dividing this interval into \(n\) subintervals
\(r_{i,j}\) and focus on the first subinterval \(r_{i,0}\). Then the
minimum number of people who could be within \(r_{i,0}\) occurs when
\(f\) is a linear function of slope \(\kappa\) and assumes some minimum
value \(f (a)\) at the start of \(r_{i, 0}\). In this instance, the
number of people in \(r_{i, 0}\) will equal:

\begin{align*}
||r_{i, 0}|| = \int_a^{a+w/n} f (x)\ dx \ge \int_a^{a+w/n} \kappa\ x + f (a)\ dx = \frac{\kappa\ w^2}{2\ n^2}  + \frac{w}{n}f (a)
\end{align*}

where:

\begin{align*}
f (a) = \frac{|s_i|}{w} - \frac{\kappa\ w}{2}.
\end{align*}

From similar calculations we find that:

\begin{align*}
\frac{s_i}{n} + \frac{k\ w^2}{2n}(\frac{1}{n} - 1) \le ||r_{i, j}|| \le \frac{s_i}{n} + \frac{k\ w^2}{2n}(1 - \frac{1}{n})
\end{align*}

\hypertarget{uniform-estimator}{%
\subsection{Uniform Estimator}\label{uniform-estimator}}

Next, Let's consider how we might subdivide a partition interval and
estimate the number of people within each subinterval. The simplest
approach is to assume that the underlying distribution function is
approximately uniformly distributed across these intervals. Thus, given
an interval \(p_i := [a, a+w]\) with \(s_i\) people in it, we can divide
the interval into \(n\) subintervals \(r_{i, j}\) and assign
\(m_{i,j} := s_i/n\) people to each.

\hypertarget{error-bounds}{%
\subsubsection{Error Bounds}\label{error-bounds}}

If we assume that the underlying distribution is differentiable with
maximum derivative \(\kappa\), we can prove that the maximum interval
population estimate error \(\epsilon\) is constrained by:

\begin{align*}
|\epsilon| \le |\frac{k\ w^2}{2n}(1 - \frac{1}{n})|
\end{align*}

\hypertarget{algorithm}{%
\subsubsection{Algorithm}\label{algorithm}}

The \texttt{refineUniform} function presented in Appendix 2 implements
this method.

\hypertarget{linear-estimator}{%
\subsection{Linear Estimator}\label{linear-estimator}}

We may be able to do better than uniform estimator however. Consider a
partition \(p\), where each interval \(p_i\) has \(s_i\) people in it.
Often it is reasonable to assume that increases and decreases from
\(s_i\) to \(s_{i+1}\) reflect changes in the underlying distribution.
If so, we can try to reflect these underlying changes by assuming that
the distribution across a series of subintervals is not uniform but
linearly increasing and decreasing.

To understand how we can do this, imagine that we draw line segments
connecting the starting points of each interval. This produces a
continuous (non-smooth) curve \(g (x)\). We then assume that the
underlying population distribution function \(f (x)\) is approximately
proportional to \(g (x)\):

\begin{align*}
\exists \lambda \in \mathbb{R}, \forall x \in \mathbb{R}^+ f (x) \approx \lambda\ g(x).
\end{align*}

Our challenge then is to calculate the scaling factor \(\lambda\) such
the number of people allocated to each interval \(p_i\) equals the
observed values \(|s_i|\).

Let's focus on a single interval \(p_i = [a, a+w]\). Over this interval
\(g (x)\) will be a linear equation thus:
\(\exists k_0 \in \mathbb{R}, g (x) := k_0 x + g (a)\). We will derive
an estimate for the underlying distribution function
\(\hat{f}_i (x) := \lambda\ g (x) = \lambda (k_0 x + g (a)) = \lambda k_0 x + \hat{f}_i (a)\)
that we assume approximates \(f (x)\) over the interval.

Our challenge is to solve for \(\lambda\).

\begin{align*}
|s_i| = \int_a^{a+w} \hat{f}_i(x)\ dx = \int_a^{a+w} \lambda\ g(x)\ dx = \lambda \int_a^{a+w}k_0\ x + g (a)\ dx = \lambda (\frac{k_0\ w^2}{2} + g(a) w) 
\end{align*}

Thus:

\begin{align*}
\lambda = \frac{2\ |s_i|}{w\ (k_0\ w + 2\ g (a))}.
\end{align*}

From these considerations we derive our estimator.

\begin{align*}
\hat{f}_i (x) := \frac{2\ |s_i| (k_0 x + g (a))}{w(k_0 w + 2 g(a))}.
\end{align*}

If we divide our interval \(p_i\) into \(n\) equal subintervals
\(r_{i,j}\) the number of people \(m_{i,j}\) we estimate lie within each
subinterval will equal:

\begin{align*}
m_{i,j} &= \int_{a+jw/n}^{a+(j+1)w/n} \hat{f}_i (x) dx\\
\\
&= \frac{|s_i|(2 j k_0 w + k_0 w + 2 n\ g(a))}{n^2 (k_0 w + 2\ g(a))}.
\end{align*}

\hypertarget{error-bounds-2}{%
\subsubsection{Error Bounds}\label{error-bounds-2}}

We can now ask ourselves what the maximum error bounds are for this
estimator. In our case. the worst possibility is for the true
distribution function to be linear over each interval with a slope
\(\kappa\) that is opposite to ours. Note that, we assume that the
function is smoothed at the interval transitions to avoid
discontinuities.

\hypertarget{algorithm-2}{%
\subsubsection{Algorithm}\label{algorithm-2}}

The \texttt{refineLinear} function presented in Appendix 2 implements
this method.

\hypertarget{appendix-2-r-code-sample}{%
\section{Appendix 2: R Code Sample}\label{appendix-2-r-code-sample}}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# This package contains definitions that can be used to represent and combine}
\CommentTok{# stratified datasets.}
\CommentTok{#}
\CommentTok{# An annotated partition is a list of contiguous non-overlapping closed-open}
\CommentTok{# intervals that span a subset of the real number line where each interval is}
\CommentTok{# associated with a value.}
\CommentTok{#}
\CommentTok{# The functions defined below assume that the intervals are listed in}
\CommentTok{# increasing order. The last interval may be unbounded.}
\CommentTok{#}
\CommentTok{# At the end of this file, we use these definitions to describe the prevalence}
\CommentTok{# of HIV and gonorrhea across Baltimore City.}

\NormalTok{UNBOUND=}\KeywordTok{quote}\NormalTok{(unbound)}

\CommentTok{# Accepts two real numbers x and y that may be "unbound" and compares them.}
\NormalTok{boundCompare <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (x, y) \{}
  \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{==}\StringTok{ }\NormalTok{y) }\DecValTok{0}
  \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{<}\StringTok{ }\NormalTok{y }\OperatorTok{||}\StringTok{ }\NormalTok{y }\OperatorTok{==}\StringTok{ }\NormalTok{UNBOUND) }\DecValTok{-1}
  \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{>}\StringTok{ }\NormalTok{y }\OperatorTok{||}\StringTok{ }\NormalTok{x }\OperatorTok{==}\StringTok{ }\NormalTok{UNBOUND) }\DecValTok{1}
\NormalTok{\}}

\CommentTok{# Accepts two real numbers x and y that may be "unbound" and returns true iff x}
\CommentTok{# is less than or equal to y.}
\NormalTok{boundLte <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (x, y) }\KeywordTok{boundCompare}\NormalTok{ (x, y) }\OperatorTok{<=}\StringTok{ }\DecValTok{0}

\CommentTok{# Accepts two real numbers who may be "unbound" and returns the smaller of them.}
\NormalTok{boundMin <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (x, y) \{}
  \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{==}\StringTok{ }\NormalTok{UNBOUND) y}
  \ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (y }\OperatorTok{==}\StringTok{ }\NormalTok{UNBOUND) x}
  \ControlFlowTok{else} \KeywordTok{min}\NormalTok{ (x, y)}
\NormalTok{\}}

\CommentTok{# Constructs an annotated interval}
\CommentTok{# These objects represent closed-open intervals in the real number line.}
\CommentTok{# @param info the "annotation value" associated with the interval}
\CommentTok{# @param start the interval's lower bound}
\CommentTok{# @param end the interval's upper bound}
\CommentTok{# Note that interval's upper bounds can be unbounded}
\NormalTok{interval <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (info, start, }\DataTypeTok{end =}\NormalTok{ UNBOUND) \{}
  \KeywordTok{list}\NormalTok{ (}\DataTypeTok{info=}\NormalTok{info, }\DataTypeTok{start=}\NormalTok{start, }\DataTypeTok{end=}\NormalTok{end)}
\NormalTok{\}}

\CommentTok{# Accepts three arguments:}
\CommentTok{# @param f a function that accepts two lists of annotations of intervals that }
\CommentTok{#   span the same range of the positive real number line and merges them}
\CommentTok{# @param xs, an annotated partition}
\CommentTok{# @param ys, an annotated partition}
\CommentTok{# and returns a new annotated partition based on the most granular intervals}
\CommentTok{# spanned by xs and ys whose annotations are derived from f.}
\NormalTok{rebase <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (f, xs, ys) \{}
\NormalTok{  zs <-}\StringTok{ }\KeywordTok{list}\NormalTok{ ()}
\NormalTok{  i <-}\StringTok{ }\DecValTok{1}
\NormalTok{  j <-}\StringTok{ }\DecValTok{1}
  \ControlFlowTok{while}\NormalTok{ (i }\OperatorTok{<=}\StringTok{ }\KeywordTok{length}\NormalTok{ (xs) }\OperatorTok{&&}\StringTok{ }\NormalTok{j }\OperatorTok{<=}\StringTok{ }\KeywordTok{length}\NormalTok{ (ys)) \{}
\NormalTok{    x <-}\StringTok{ }\NormalTok{xs[[i]]}
\NormalTok{    y <-}\StringTok{ }\NormalTok{ys[[j]]}
    \ControlFlowTok{if}\NormalTok{ (x}\OperatorTok{$}\NormalTok{start }\OperatorTok{==}\StringTok{ }\NormalTok{y}\OperatorTok{$}\NormalTok{start) \{}
\NormalTok{      xInfos <-}\StringTok{ }\KeywordTok{c}\NormalTok{ ()}
\NormalTok{      yInfos <-}\StringTok{ }\KeywordTok{c}\NormalTok{ ()}
\NormalTok{      start <-}\StringTok{ }\NormalTok{x}\OperatorTok{$}\NormalTok{start}
      \ControlFlowTok{while}\NormalTok{ (i }\OperatorTok{<=}\StringTok{ }\KeywordTok{length}\NormalTok{ (xs) }\OperatorTok{&&}\StringTok{ }\NormalTok{j }\OperatorTok{<=}\StringTok{ }\KeywordTok{length}\NormalTok{ (ys)) \{}
\NormalTok{        x <-}\StringTok{ }\NormalTok{xs[[i]]}
\NormalTok{        y <-}\StringTok{ }\NormalTok{ys[[j]]}
        \ControlFlowTok{if}\NormalTok{ (}
          \KeywordTok{boundCompare}\NormalTok{ (x}\OperatorTok{$}\NormalTok{end, y}\OperatorTok{$}\NormalTok{end) }\OperatorTok{==}\StringTok{ }\DecValTok{0} \OperatorTok{||}
\StringTok{          }\NormalTok{(y}\OperatorTok{$}\NormalTok{end }\OperatorTok{==}\StringTok{ }\NormalTok{UNBOUND }\OperatorTok{&&}\StringTok{ }\NormalTok{i }\OperatorTok{==}\StringTok{ }\KeywordTok{length}\NormalTok{ (xs)) }\OperatorTok{||}
\StringTok{          }\NormalTok{(x}\OperatorTok{$}\NormalTok{end }\OperatorTok{==}\StringTok{ }\NormalTok{UNBOUND }\OperatorTok{&&}\StringTok{ }\NormalTok{j }\OperatorTok{==}\StringTok{ }\KeywordTok{length}\NormalTok{ (ys))}
\NormalTok{        ) \{}
\NormalTok{          zs <-}\StringTok{ }\KeywordTok{append}\NormalTok{ (zs,}
            \KeywordTok{list}\NormalTok{ (}\KeywordTok{interval}\NormalTok{ (}
              \DataTypeTok{info=}\KeywordTok{f}\NormalTok{ (}
                \KeywordTok{c}\NormalTok{ (xInfos, x}\OperatorTok{$}\NormalTok{info),}
                \KeywordTok{c}\NormalTok{ (yInfos, y}\OperatorTok{$}\NormalTok{info)}
\NormalTok{              ),}
              \DataTypeTok{start=}\NormalTok{start,}
              \DataTypeTok{end=}\KeywordTok{boundMin}\NormalTok{ (x}\OperatorTok{$}\NormalTok{end, y}\OperatorTok{$}\NormalTok{end)}
\NormalTok{          )))}
\NormalTok{          i <-}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{          j <-}\StringTok{ }\NormalTok{j }\OperatorTok{+}\StringTok{ }\DecValTok{1}
          \ControlFlowTok{break}
\NormalTok{        \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{boundCompare}\NormalTok{ (x}\OperatorTok{$}\NormalTok{end, y}\OperatorTok{$}\NormalTok{end) }\OperatorTok{==}\StringTok{ }\DecValTok{-1}\NormalTok{) \{}
\NormalTok{          xInfos <-}\StringTok{ }\KeywordTok{c}\NormalTok{ (xInfos, x}\OperatorTok{$}\NormalTok{info)}
\NormalTok{          i <-}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{ }\CommentTok{# x$end > y$end}
\NormalTok{          yInfos <-}\StringTok{ }\KeywordTok{c}\NormalTok{ (yInfos, y}\OperatorTok{$}\NormalTok{info)}
\NormalTok{          j <-}\StringTok{ }\NormalTok{j }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{        \}}
\NormalTok{      \}}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (x}\OperatorTok{$}\NormalTok{start }\OperatorTok{<}\StringTok{ }\NormalTok{y}\OperatorTok{$}\NormalTok{start) \{}
\NormalTok{      i <-}\StringTok{ }\NormalTok{i }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{ }\CommentTok{# x$start > y$start}
\NormalTok{      j <-}\StringTok{ }\NormalTok{j }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  zs}
\NormalTok{\}}

\CommentTok{# Accepts two partitions:}
\CommentTok{# @param ps a partition that represents the number of people in a population who}
\CommentTok{#   fall within a contiguous set of age ranges}
\CommentTok{# @param rs a partition that represents the proportion of people within a}
\CommentTok{#   contiguous set of age ranges who have some condition}
\CommentTok{# and returns a partition that gives the absolute number of people who have the}
\CommentTok{# condition within the most granular set of age ranges spanned by both}
\CommentTok{# ps and rs.}
\NormalTok{getFrequency <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (ps, rs) \{}
  \KeywordTok{rebase}\NormalTok{ (}
    \ControlFlowTok{function}\NormalTok{ (sizes, rates) \{}
      \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{ (rates) }\OperatorTok{!=}\StringTok{ }\DecValTok{1}\NormalTok{) \{}
        \KeywordTok{stop}\NormalTok{ (}\StringTok{"Error: the population partition is not a }\CharTok{\textbackslash{}"}\StringTok{refinement}\CharTok{\textbackslash{}"}\StringTok{ of the rate partition"}\NormalTok{)}
\NormalTok{      \}}
\NormalTok{      rates[}\DecValTok{1}\NormalTok{]}\OperatorTok{*}\KeywordTok{sum}\NormalTok{ (sizes)}
\NormalTok{    \}, ps, rs}
\NormalTok{  )}
\NormalTok{\}}

\CommentTok{# Accepts three arguments:}
\CommentTok{# @start the age range lower bound}
\CommentTok{# @end the age range upper bound}
\CommentTok{# @freqs the number of people who have a given condition for a set of age ranges}
\CommentTok{# and returns the total number of people who have the given condition between}
\CommentTok{# the start and end age range (inclusive).}
\NormalTok{getFreqSum <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (start, end, freqs) \{}
\NormalTok{  sum <-}\StringTok{ }\DecValTok{0}
  \ControlFlowTok{for}\NormalTok{ (freq }\ControlFlowTok{in}\NormalTok{ freqs) \{}
    \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{boundLte}\NormalTok{ (freq}\OperatorTok{$}\NormalTok{end, end)) }\ControlFlowTok{break}

    \ControlFlowTok{if}\NormalTok{ (start }\OperatorTok{<=}\StringTok{ }\NormalTok{freq}\OperatorTok{$}\NormalTok{start) sum <-}\StringTok{ }\NormalTok{sum }\OperatorTok{+}\StringTok{ }\NormalTok{freq}\OperatorTok{$}\NormalTok{info}
\NormalTok{  \}}
\NormalTok{  sum}
\NormalTok{\}}

\CommentTok{# Accepts two partitions:}
\CommentTok{# @param xs a partition that gives the number of people within a contiguous set}
\CommentTok{#   of age ranges who have condition x}
\CommentTok{# @param ys a partition that gives the number of people within a contiguous set}
\CommentTok{#   of age ranges who have condition y}
\CommentTok{# and returns the rate ratios of the two conditions over the most granular}
\CommentTok{# partition spanned by both xs and ys.}
\NormalTok{getFreqRateRatio <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (xs, ys) \{}
  \KeywordTok{rebase}\NormalTok{ (}\ControlFlowTok{function}\NormalTok{ (freqs0, freqs1) }\KeywordTok{sum}\NormalTok{ (freqs0)}\OperatorTok{/}\KeywordTok{sum}\NormalTok{ (freqs1), xs, ys)}
\NormalTok{\}}

\CommentTok{# Accepts three partitions:}
\CommentTok{# @param ps a partition that gives the number of people who fall into a}
\CommentTok{#   contiguous set of real intervals}
\CommentTok{# @param xs a partition that gives the proportion of people within a range of}
\CommentTok{#   intervals who have a condition x}
\CommentTok{# @param ys a partition that gives the proportion of people within a range of}
\CommentTok{#   intervals who have a condition y}
\CommentTok{# and returns the rate ratio of the number of people who have condition x and y}
\CommentTok{# over the most granular common partition that spans xs and ys.}
\NormalTok{getRateRatio <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (ps, xs, ys) \{}
\NormalTok{  xFreq <-}\StringTok{ }\KeywordTok{getFrequency}\NormalTok{ (ps, xs)}
\NormalTok{  yFreq <-}\StringTok{ }\KeywordTok{getFrequency}\NormalTok{ (ps, ys)}
  \KeywordTok{getFreqRateRatio}\NormalTok{ (xFreq, yFreq)}
\NormalTok{\}}

\CommentTok{# Accepts one argumnet:}
\CommentTok{# @param xs, an annotated partition}
\CommentTok{# and returns a new annotated partition in which every interval in xs has been}
\CommentTok{# subdivided into subintervals of width one and the value assigned to those}
\CommentTok{# intervals has been distributed equally across the subintervals.}
\CommentTok{# Note: This function skips all unbound intervals.}
\NormalTok{refineUniform <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (xs) \{}
\NormalTok{  ys <-}\StringTok{ }\KeywordTok{list}\NormalTok{ ()}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{ (xs)) \{}
\NormalTok{    x <-}\StringTok{ }\NormalTok{xs[[i]]}
    \ControlFlowTok{if}\NormalTok{ (x}\OperatorTok{$}\NormalTok{start }\OperatorTok{==}\StringTok{ }\NormalTok{UNBOUND }\OperatorTok{||}\StringTok{ }\NormalTok{x}\OperatorTok{$}\NormalTok{end }\OperatorTok{==}\StringTok{ }\NormalTok{UNBOUND) }\ControlFlowTok{next}
\NormalTok{    w <-}\StringTok{ }\NormalTok{x}\OperatorTok{$}\NormalTok{end }\OperatorTok{-}\StringTok{ }\NormalTok{x}\OperatorTok{$}\NormalTok{start}
    \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{0}\OperatorTok{:}\NormalTok{(n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)) \{}
\NormalTok{      ys <-}\StringTok{ }\KeywordTok{append}\NormalTok{ (ys,}
        \KeywordTok{list}\NormalTok{ (}\KeywordTok{interval}\NormalTok{ (}
          \DataTypeTok{info=}\NormalTok{x}\OperatorTok{$}\NormalTok{info}\OperatorTok{/}\NormalTok{w,}
          \DataTypeTok{start=}\NormalTok{x}\OperatorTok{$}\NormalTok{start }\OperatorTok{+}\StringTok{ }\NormalTok{j,}
          \DataTypeTok{end=}\NormalTok{x}\OperatorTok{$}\NormalTok{start }\OperatorTok{+}\StringTok{ }\NormalTok{j }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{      )))}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  ys}
\NormalTok{\}}

\CommentTok{# Accepts one argument:}
\CommentTok{# @param xs, an annotated partition}
\CommentTok{# and returns a new annotated partition in which every interval in xs has been}
\CommentTok{# subdivided into equal subintervals of width one and the value assigned to}
\CommentTok{# those intervals has been distributed across the subintervals using the}
\CommentTok{# linear (not the uniform) estimator.}
\CommentTok{# Note: This function skips all unbound intervals. }
\NormalTok{refineLinear <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (xs) \{}
\NormalTok{  ys <-}\StringTok{ }\KeywordTok{list}\NormalTok{ ()}
  \ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{ (xs)) \{}
\NormalTok{    x <-}\StringTok{ }\NormalTok{xs[[i]]}
    \ControlFlowTok{if}\NormalTok{ (x}\OperatorTok{$}\NormalTok{start }\OperatorTok{==}\StringTok{ }\NormalTok{UNBOUND }\OperatorTok{||}\StringTok{ }\NormalTok{x}\OperatorTok{$}\NormalTok{end }\OperatorTok{==}\StringTok{ }\NormalTok{UNBOUND) }\ControlFlowTok{next}
\NormalTok{    prevInfo <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{-}\StringTok{ }\DecValTok{1} \OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) xs[[i }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{]]}\OperatorTok{$}\NormalTok{info }\ControlFlowTok{else} \DecValTok{0} 
\NormalTok{    nextInfo <-}\StringTok{ }\ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{+}\StringTok{ }\DecValTok{1} \OperatorTok{<=}\StringTok{ }\KeywordTok{length}\NormalTok{ (xs)) xs[[i }\OperatorTok{+}\StringTok{ }\DecValTok{1}\NormalTok{]]}\OperatorTok{$}\NormalTok{info }\ControlFlowTok{else} \DecValTok{0}
\NormalTok{    w <-}\StringTok{ }\NormalTok{x}\OperatorTok{$}\NormalTok{end }\OperatorTok{-}\StringTok{ }\NormalTok{x}\OperatorTok{$}\NormalTok{start}
\NormalTok{    k <-}\StringTok{ }\NormalTok{(nextInfo }\OperatorTok{-}\StringTok{ }\NormalTok{x}\OperatorTok{$}\NormalTok{info)}\OperatorTok{/}\NormalTok{w}
    \ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{0}\OperatorTok{:}\NormalTok{(w }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)) \{}
\NormalTok{      ys <-}\StringTok{ }\KeywordTok{append}\NormalTok{ (ys,}
        \KeywordTok{list}\NormalTok{ (}\KeywordTok{interval}\NormalTok{ (}
          \DataTypeTok{info=}\NormalTok{x}\OperatorTok{$}\NormalTok{info}\OperatorTok{*}\NormalTok{(}\DecValTok{2}\OperatorTok{*}\NormalTok{j}\OperatorTok{*}\NormalTok{k}\OperatorTok{*}\NormalTok{w }\OperatorTok{+}\StringTok{ }\NormalTok{k}\OperatorTok{*}\NormalTok{w }\OperatorTok{+}\StringTok{ }\DecValTok{2}\OperatorTok{*}\NormalTok{w}\OperatorTok{*}\NormalTok{prevInfo)}\OperatorTok{/}
\StringTok{               }\NormalTok{((w}\OperatorTok{^}\DecValTok{2}\NormalTok{)}\OperatorTok{*}\NormalTok{(k}\OperatorTok{*}\NormalTok{w }\OperatorTok{+}\StringTok{ }\DecValTok{2}\OperatorTok{*}\NormalTok{prevInfo)),}
          \DataTypeTok{start=}\NormalTok{x}\OperatorTok{$}\NormalTok{start }\OperatorTok{+}\StringTok{ }\NormalTok{j,}
          \DataTypeTok{end=}\NormalTok{x}\OperatorTok{$}\NormalTok{start }\OperatorTok{+}\StringTok{ }\NormalTok{j }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\NormalTok{      )))}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{  ys}
\NormalTok{\}}

\CommentTok{# A partition listing the number of Baltimore residents who's ages fall within}
\CommentTok{# a contiguous set of age ranges.}
\NormalTok{population =}\StringTok{ }\KeywordTok{list}\NormalTok{ (}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{36355}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{4}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{33773}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{9}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{33590}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{14}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{33872}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{19}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{37183}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{24}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{53357}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{29}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{54804}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{34}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{43408}\NormalTok{, }\DecValTok{35}\NormalTok{, }\DecValTok{39}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{34271}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{44}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{30273}\NormalTok{, }\DecValTok{45}\NormalTok{, }\DecValTok{49}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{33423}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{54}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{37639}\NormalTok{, }\DecValTok{55}\NormalTok{, }\DecValTok{59}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{36895}\NormalTok{, }\DecValTok{60}\NormalTok{, }\DecValTok{64}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{29868}\NormalTok{, }\DecValTok{65}\NormalTok{, }\DecValTok{69}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{22486}\NormalTok{, }\DecValTok{70}\NormalTok{, }\DecValTok{74}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{13910}\NormalTok{, }\DecValTok{75}\NormalTok{, }\DecValTok{79}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{8977}\NormalTok{, }\DecValTok{80}\NormalTok{, }\DecValTok{84}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{9073}\NormalTok{, }\DecValTok{85}\NormalTok{)}
\NormalTok{)}

\CommentTok{# A partition listing the rates of HIV amongst Baltimore residents falling}
\CommentTok{# within certain age ranges.}
\NormalTok{hivRates =}\StringTok{ }\KeywordTok{list}\NormalTok{ (}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{45.6e-5}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{24}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{53.6e-5}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{34}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{46.6e-5}\NormalTok{, }\DecValTok{35}\NormalTok{, }\DecValTok{44}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{26.7e-5}\NormalTok{, }\DecValTok{45}\NormalTok{, }\DecValTok{54}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{5.4e-5}\NormalTok{, }\DecValTok{55}\NormalTok{, }\DecValTok{64}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{30.4e-5}\NormalTok{, }\DecValTok{65}\NormalTok{)}
\NormalTok{)}

\CommentTok{#  A partition list the rates of Gonorrhea amongst Baltimore residents falling}
\CommentTok{# within certain age ranges.}
\NormalTok{gonorrheaRates =}\StringTok{ }\KeywordTok{list}\NormalTok{ (}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{25.7e-5}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{14}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{2021.6e-5}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{19}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{2647.6e-5}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{24}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{1477.8e-5}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{29}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{1047.3e-5}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{34}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{773.0e-5}\NormalTok{, }\DecValTok{35}\NormalTok{, }\DecValTok{39}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{490.3e-5}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{44}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{298.6e-5}\NormalTok{, }\DecValTok{45}\NormalTok{, }\DecValTok{54}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{139.5e-5}\NormalTok{, }\DecValTok{55}\NormalTok{, }\DecValTok{64}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{23.6e-5}\NormalTok{, }\DecValTok{65}\NormalTok{)}
\NormalTok{)}

\CommentTok{# A partition listing the rates of heroin use amongst Baltimore residents}
\CommentTok{# falling within certain age ranges}
\CommentTok{# Note: The handout appears to have a typo in which heroin usage rates are}
\CommentTok{# reported as "rates per 100,000"}
\NormalTok{heroinRates =}\StringTok{ }\KeywordTok{list}\NormalTok{ (}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{0.00112}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{17}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{0.005426598}\NormalTok{, }\DecValTok{18}\NormalTok{, }\DecValTok{25}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\FloatTok{0.009849983}\NormalTok{, }\DecValTok{26}\NormalTok{)}
\NormalTok{)}

\CommentTok{# A partition listing the number of Baltimore residents who's ages fall within}
\CommentTok{# a contiguous set of age ranges.}
\NormalTok{populationRefine =}\StringTok{ }\KeywordTok{list}\NormalTok{ (}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{103718}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{14}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{33872}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{19}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{37183}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DecValTok{24}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{108161}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{34}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{43408}\NormalTok{, }\DecValTok{35}\NormalTok{, }\DecValTok{39}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{34271}\NormalTok{, }\DecValTok{40}\NormalTok{, }\DecValTok{44}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{63696}\NormalTok{, }\DecValTok{45}\NormalTok{, }\DecValTok{54}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{74534}\NormalTok{, }\DecValTok{55}\NormalTok{, }\DecValTok{64}\NormalTok{),}
  \KeywordTok{interval}\NormalTok{ (}\DecValTok{84314}\NormalTok{, }\DecValTok{65}\NormalTok{)}
\NormalTok{)}

\CommentTok{# The number of people within certain age ranges who have HIV }
\NormalTok{hivFreq =}\StringTok{ }\KeywordTok{getFrequency}\NormalTok{ (population, hivRates)}

\CommentTok{# The number of people within certain age ranges who have Gonorrhea}
\NormalTok{gonorrheaFreq =}\StringTok{ }\KeywordTok{getFrequency}\NormalTok{ (population, gonorrheaRates)}

\CommentTok{# The number of people within certain age ranges who use heroin}
\NormalTok{heroinFreq =}\StringTok{ }\KeywordTok{getFrequency}\NormalTok{ (population, heroinRates)}

\CommentTok{# The rate ratio of gonorrhea and HIV for people aged 25 to 44}
\CommentTok{# Note: the answer to question 1.(a)}
\NormalTok{gonorrheaHivFreq2544 =}
\StringTok{  }\KeywordTok{getFreqSum}\NormalTok{ (}\DecValTok{25}\NormalTok{, }\DecValTok{44}\NormalTok{, gonorrheaFreq)}\OperatorTok{/}
\StringTok{  }\KeywordTok{getFreqSum}\NormalTok{ (}\DecValTok{25}\NormalTok{, }\DecValTok{44}\NormalTok{, hivFreq)}

\CommentTok{# The rate ratio of gonorrhea and HIV for people aged 45 and older}
\CommentTok{# Note: the answer to question 1.(b)}
\NormalTok{gonorrheaHivfreq =}
\StringTok{  }\KeywordTok{getFreqSum}\NormalTok{ (}\DecValTok{45}\NormalTok{, UNBOUND, gonorrheaFreq)}\OperatorTok{/}
\StringTok{  }\KeywordTok{getFreqSum}\NormalTok{ (}\DecValTok{45}\NormalTok{, UNBOUND, hivFreq)}

\CommentTok{# Estimates the number of people within the age ranges used to partition}
\CommentTok{#   populationRefine that have gonorrhea.}
\CommentTok{# Note: this simulates the dataset that could have been provided for 3.}
\NormalTok{gonorrheaFreqRefine =}\StringTok{ }\KeywordTok{rebase}\NormalTok{ (}
  \ControlFlowTok{function}\NormalTok{ (xs, ys) }\KeywordTok{sum}\NormalTok{ (xs),}
  \KeywordTok{refineLinear}\NormalTok{ (gonorrheaFreq),}
\NormalTok{  populationRefine) }

\CommentTok{# Estimates the number of people for each age cohort who has gonorrhea.}
\CommentTok{# Note: this answers question 3.}
\NormalTok{gonorrheaFreqLinearRefinement =}\StringTok{ }\KeywordTok{refineLinear}\NormalTok{ (gonorrheaFreqRefine)}
\end{Highlighting}
\end{Shaded}

\end{document}
